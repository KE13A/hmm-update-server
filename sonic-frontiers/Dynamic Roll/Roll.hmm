//===========================================================================================================
// Rolling Functionality
Code "Dynamic Roll" in "Gameplay" by "KE13A" 
//
	#include "Reflection" noemit
    #include "BlackboardStatus" noemit

    #lib "BlackboardStatus"
    #lib "Time"
    #lib "Globals"
    #lib "Memory"
    #lib "Player"

    #import "Plugins"

    #load "System.Numerics.dll"

    using System.Numerics;
    
    static float springLandTimer = 0.0f;
    static bool airBallActive = false;
//
{
    Globals.Set("Drop Dash Over Spin Dash", false);

    var currentState = Player.State.GetCurrentStateID<Sonic.StateID>();
    var previousState = Player.State.GetPreviousStateID<Sonic.StateID>();

    bool isBoomPressed = Player.Input.IsPressed(Player.InputActionType.PlayerSonicboom);
    bool isBoomDown = Player.Input.IsDown(Player.InputActionType.PlayerSonicboom);
    bool isBoomReleased = Player.Input.IsReleased(Player.InputActionType.PlayerSonicboom);

    bool Rolling =
    currentState == Sonic.StateID.StateSpin ||
    currentState == Sonic.StateID.StateDropDash ||
    currentState == Sonic.StateID.StateDriftDash ||
    currentState == Sonic.StateID.StateSpinBoost ||
    currentState == Sonic.StateID.StateSpinBoostCharge;

    bool Jumped =
    previousState == Sonic.StateID.StateJump ||
    previousState == Sonic.StateID.StateBaseJump ||
    previousState == Sonic.StateID.StateBumpJump ||
    previousState == Sonic.StateID.StateWallJump ||
    previousState == Sonic.StateID.StateBounceJump ||
    previousState == Sonic.StateID.StateDoubleJump ||
    previousState == Sonic.StateID.StateFall ||
    previousState == Sonic.StateID.StateGrindJump ||
    previousState == Sonic.StateID.StateGrindDoubleJump;

    var kinematics = Player.Kinematics.Get();

    if (BlackboardStatus.Get() == null)
    {
        return;
    }

    // === LT pressed - State Redirects and Discards ===
    if (Player.Status.IsSideView())
    {
        Player.State.Redirect<Sonic.StateID>(Sonic.StateID.StateSpinBoost, Sonic.StateID.StateSpin);
        Player.State.Redirect<Amy.StateID>(Amy.StateID.StateSpinBoost, Amy.StateID.StateSpin);
        Player.State.Redirect<Knuckles.StateID>(Knuckles.StateID.StateSpinBoost, Knuckles.StateID.StateSpin);
        Player.State.Redirect<Tails.StateID>(Tails.StateID.StateSpinBoost, Tails.StateID.StateSpin);
    }
    else
    {
        Player.State.Redirect<Sonic.StateID>(Sonic.StateID.StateSpinBoost, Sonic.StateID.StateDriftDash);
        Player.State.Redirect<Amy.StateID>(Amy.StateID.StateSpinBoost, Amy.StateID.StateDriftDash);
        Player.State.Redirect<Knuckles.StateID>(Knuckles.StateID.StateSpinBoost, Knuckles.StateID.StateDriftDash);
        Player.State.Redirect<Tails.StateID>(Tails.StateID.StateSpinBoost, Tails.StateID.StateDriftDash);
    }

    if (Rolling)
    {
        Player.State.Discard<Sonic.StateID>(Sonic.StateID.StateDropDash);
        Player.State.Discard<Amy.StateID>(Amy.StateID.StateDropDash);
        Player.State.Discard<Knuckles.StateID>(Knuckles.StateID.StateDropDash);
        Player.State.Discard<Tails.StateID>(Tails.StateID.StateDropDash);
    }
    else
    {
        Player.State.Restore<Sonic.StateID>(Sonic.StateID.StateDropDash);
        Player.State.Restore<Amy.StateID>(Amy.StateID.StateDropDash);
        Player.State.Restore<Knuckles.StateID>(Knuckles.StateID.StateDropDash);
        Player.State.Restore<Tails.StateID>(Tails.StateID.StateDropDash);           
    }

    Player.State.Discard<Sonic.StateID>(Sonic.StateID.StateSpinBoostCharge);
    Player.State.Discard<Amy.StateID>(Amy.StateID.StateSpinBoostCharge);
    Player.State.Discard<Knuckles.StateID>(Knuckles.StateID.StateSpinBoostCharge);
    Player.State.Discard<Tails.StateID>(Tails.StateID.StateSpinBoostCharge);

    //Slide Trasition to Roll 
    if (currentState == Sonic.StateID.StateSliding)
    {
        if (isBoomDown)
        {
            Player.Animation.SetAnimation("JUMP_BALL"); 

            var vel = kinematics->Velocity;

            if (Player.Status.IsSideView())
            {
                Player.State.SetState(Sonic.StateID.StateSpin);
            }
            else
            {
                Player.State.SetState(Sonic.StateID.StateDriftDash);
            }

            kinematics->Velocity = vel;
        }
    }

    // Airborne spinball check
    if (!Player.Status.IsGrounded() && isBoomDown)
    {
        airBallActive = true;
    }


    // === LT release ===
    if (isBoomReleased)
    {
        if (Jumped || Rolling)
        {
            var vel = kinematics->Velocity;
            if (Player.Input.IsPressed(Player.InputActionType.PlayerJump))
            {
                Player.State.SetState(Sonic.StateID.StateBaseJump);
                kinematics->Velocity = vel;
            }
            else if (Player.Input.IsDown(Player.InputActionType.PlayerBoost))
            {
                if (Memory.TryGetPointer<StatePluginBoost>(Player.State.GetStatePlugin<StatePluginBoost>(), out var out_pStatePluginBoost))
                {
                    if ((out_pStatePluginBoost->Flags & StatePluginBoost.BoostFlags.IsGaugeEmpty) == 0)
                    {
                        Player.State.SetState(Sonic.StateID.StateStandRoot);
                        SET_STATE_FLAG(IsBoost, true);
                    }
                }
            }
            else if (Player.Status.IsGrounded())
            {
                Player.State.SetState(Sonic.StateID.StateSpringJumpHeadLand);
            }
        }

        airBallActive = false;
    }


    // === Landing & Exiting checks ===
    // Re-enter DriftDash if LT is held
    if (Player.Status.IsGrounded() && airBallActive && currentState != Sonic.StateID.StateRecoveryJump)
    {
        var vel = kinematics->Velocity;

        if (Player.Status.IsSideView())
        {
            Player.State.SetState(Sonic.StateID.StateSpin);
            kinematics->Velocity = vel;
        }
        else
        {
            Player.State.SetState(Sonic.StateID.StateDriftDash);
        }

        airBallActive = false;
    }

    // SpringJumpHeadLand exit handling
    if (currentState == Sonic.StateID.StateSpringJumpHeadLand)
    {
        var vel = kinematics->Velocity;
        springLandTimer += Time.GetDeltaTime();

        if (Player.Input.IsPressed(Player.InputActionType.PlayerJump))
        {
            Player.State.SetState(Sonic.StateID.StateBaseJump);
            springLandTimer = 0.0f;
        }
        else if (Player.Input.IsPressed(Player.InputActionType.PlayerStomping) && Player.GetPlayerType() == Player.PlayerType.Sonic)
        {
            Player.State.SetState(Sonic.StateID.StateSliding);
            springLandTimer = 0.0f;
        }
        else if (Player.Input.IsPressed(Player.InputActionType.PlayerBoost))
        {
            Player.State.SetState(Sonic.StateID.StateSpinBoost);
            springLandTimer = 0.0f;
        }
        else if (springLandTimer >= 0.2f)
        {
            if (Player.Status.IsGrounded())
            {
                if (isBoomDown)
                {
                    if (Player.Status.IsSideView())
                    {
                        Player.State.SetState(Sonic.StateID.StateSpin);
                        kinematics->Velocity = vel;
                    }
                    else
                    {
                        Player.State.SetState(Sonic.StateID.StateDriftDash);
                    }
                }
                else if (Player.Input.IsDown(Player.InputActionType.PlayerStomping) && Player.GetPlayerType() == Player.PlayerType.Sonic)
                {
                    Player.State.SetState(Sonic.StateID.StateSliding);
                }
                else
                {
                    Player.State.SetState(Sonic.StateID.StateRun);
                }
            }
            else
            {
                Player.State.SetState(Sonic.StateID.StateFall);
                airBallActive = false;
                kinematics->Velocity = vel;
            }
            springLandTimer = 0.0f;
        }
        else if (kinematics != null)
        {
            float dotProduct = Vector3.Dot(Vector3.Transform(Vector3.UnitY, kinematics->Rotation), Vector3.UnitY);

            if (dotProduct < 0.01f)
            {
                Player.State.SetState<Sonic.StateID>(Sonic.StateID.StateRun);
            }
        }
    }
    else
    {
        springLandTimer = 0.0f;
    }
}


Code "Crouch with Left Trigger" in "Gameplay" by "KE13A" 
//
	#include "Reflection" noemit
    #include "BlackboardStatus" noemit

    #lib "Player"
    #lib "BlackboardStatus"
//
{
    float currentSpeed = Player.Kinematics.GetMagnitude();

    if (BlackboardStatus.Get() == null)
    {
        return;
    }


    //Crouch
    if (Player.Status.IsGrounded() && currentSpeed <= 0.0f && Player.Input.IsDown(Player.InputActionType.PlayerSonicboom) && !IS_WORLD_FLAG(IsBattle))
    {
        Player.State.Discard<Sonic.StateID>(Sonic.StateID.StateStandRoot);
        Player.State.Discard<Amy.StateID>(Amy.StateID.StateStandRoot);
        Player.State.Discard<Knuckles.StateID>(Knuckles.StateID.StateStandRoot);
        Player.State.Discard<Tails.StateID>(Tails.StateID.StateStandRoot);

        Player.State.Redirect<Sonic.StateID>(Sonic.StateID.StateSpinMove, Sonic.StateID.StateSquat);
        Player.State.Redirect<Amy.StateID>(Amy.StateID.StateSpinMove, Amy.StateID.StateSquat);
        Player.State.Redirect<Knuckles.StateID>(Knuckles.StateID.StateSpinMove, Knuckles.StateID.StateSquat);
        Player.State.Redirect<Tails.StateID>(Tails.StateID.StateSpinMove, Tails.StateID.StateSquat);
    }
    else
    {
        Player.State.Restore<Sonic.StateID>(Sonic.StateID.StateStandRoot);
        Player.State.Restore<Amy.StateID>(Amy.StateID.StateStandRoot);
        Player.State.Restore<Knuckles.StateID>(Knuckles.StateID.StateStandRoot);
        Player.State.Restore<Tails.StateID>(Tails.StateID.StateStandRoot);        
    }
}



// Code "Spin Dash Charge" by "KE13A" 
// //
// 	#include "Reflection" noemit
//     #include "BlackboardStatus" noemit

//     #lib "Player"
//     #lib "BlackboardStatus"
//     #lib "Time"

//     #load "System.Numerics.dll"

//     using System.Numerics;

//     static bool IsVelocityAdded = false;
//     static float chargeCount = 1.0f;
//     static float pressTime = 0.0f;
//     static bool SpinSFX = false;
// //
// {        
   
//     var currentState = Player.State.GetCurrentStateID<Sonic.StateID>();
//     var previousState = Player.State.GetPreviousStateID<Sonic.StateID>();

//     bool isBoomPressed = Player.Input.IsPressed(Player.InputActionType.PlayerSonicboom);
//     bool isBoomDown = Player.Input.IsDown(Player.InputActionType.PlayerSonicboom);
//     bool isBoomReleased = Player.Input.IsReleased(Player.InputActionType.PlayerSonicboom);

//     bool Rolling =
//     currentState == Sonic.StateID.StateSpin ||
//     currentState == Sonic.StateID.StateDropDash ||
//     currentState == Sonic.StateID.StateDriftDash ||
//     currentState == Sonic.StateID.StateSpinBoost;

//     float currentSpeed = Player.Kinematics.GetMagnitude();


//     if ((currentState is Sonic.StateID.StateSquat or Sonic.StateID.StateSpinMove) && Player.Input.IsPressed(Player.InputActionType.PlayerBoost))
//     {
//         Player.State.Restore<Sonic.StateID>(Sonic.StateID.StateSpinBoostCharge);
//         Player.State.Restore<Amy.StateID>(Amy.StateID.StateSpinBoostCharge);
//         Player.State.Restore<Knuckles.StateID>(Knuckles.StateID.StateSpinBoostCharge);
//         Player.State.Restore<Tails.StateID>(Tails.StateID.StateSpinBoostCharge);

//         Player.State.SetState<Sonic.StateID>(Sonic.StateID.StateSpinBoostCharge);

//     }
//     // else
//     // {
//     //     Player.State.Redirect<Sonic.StateID>(Sonic.StateID.StateSpinMove, Sonic.StateID.StateSpinBoostCharge);
//     //     Player.State.Redirect<Amy.StateID>(Amy.StateID.StateSpinMove, Amy.StateID.StateSpinBoostCharge);
//     //     Player.State.Redirect<Knuckles.StateID>(Knuckles.StateID.StateSpinMove, Knuckles.StateID.StateSpinBoostCharge);
//     //     Player.State.Redirect<Tails.StateID>(Tails.StateID.StateSpinMove, Tails.StateID.StateSpinBoostCharge);        
//     // }

//     // Player.State.Discard<Sonic.StateID>(Sonic.StateID.StateSpinBoostCharge);
//     // Player.State.Discard<Amy.StateID>(Amy.StateID.StateSpinBoostCharge);
//     // Player.State.Discard<Knuckles.StateID>(Knuckles.StateID.StateSpinBoostCharge);
//     // Player.State.Discard<Tails.StateID>(Tails.StateID.StateSpinBoostCharge);

//     // Spin Dash Charging
//     if (Player.Status.IsGrounded() && Player.Input.IsPressed(Player.InputActionType.PlayerBoost) && (currentState == Sonic.StateID.StateSpinBoostCharge) && chargeCount < 6)
//     {
//         chargeCount += 1;
//         Player.Animation.SetAnimation("JUMP_BALL"); 
//         Player.Effect.PlayAnimationEffect("SPIN_CHARGE");
//         Player.Sound.PlaySound("sn_spindash");
//         SpinSFX = true;
//     }
//     else if (currentState == Sonic.StateID.StateSpinBoostCharge && chargeCount > 1)
//     {
//         chargeCount -= 0.015f;
//     }

//     if (Player.Status.IsGrounded() && Player.Input.IsReleased(Player.InputActionType.PlayerStomping) && Rolling)
//     {
//         var kinematics = Player.Kinematics.Get();

//         if (kinematics == null)
//             return;
            
//         if (!IsVelocityAdded && !IS_WORLD_FLAG(IsCyberSpace) && !Player.Status.IsSideView())
//         {
//             kinematics->Velocity = Player.Kinematics.GetForward() * (chargeCount * 7.5f + 15.0f);

//             IsVelocityAdded = true;

//             goto Reset;
//         }

//         if (!IsVelocityAdded && IS_WORLD_FLAG(IsCyberSpace) && !Player.Status.IsSideView())
//         {
//             kinematics->Velocity = Player.Kinematics.GetForward() * (chargeCount * 7.5f + 15.0f);

//             IsVelocityAdded = true;

//             goto Reset;
//         }

// 	    if (!IsVelocityAdded && Player.Status.IsSideView())
//         {
//             kinematics->Velocity = Player.Kinematics.GetForward() * (chargeCount * 4.0f + 15.0f);

//             IsVelocityAdded = true;

//             goto Reset;
//         }
//         Reset:
//             chargeCount = 1;
//             int soundHandle = Player.Sound.PlaySound("sn_spindash");
//             Player.Sound.StopSound(&soundHandle); 
//     }
//     else
//     {
//         IsVelocityAdded = false;
//     }

//     // if (currentState != Sonic.StateID.StateSpinBoostCharge)
//     // {
//     //     chargeCount = 1;
//     // }
// }


Code "Allow Rolling During Auto Run"
//
    #include "BlackboardStatus" noemit

    #lib "Player"

    #import "Plugins"
//
{
    if (!IS_WORLD_FLAG(IsAutoRun))
    {
        return;
    }

    var kinematics = Player.Kinematics.Get();
    var vel = kinematics->Velocity;
    var currentState = Player.State.GetCurrentStateID<Sonic.StateID>();

    bool Rolling =
    currentState == Sonic.StateID.StateSpin ||
    currentState == Sonic.StateID.StateDropDash ||
    currentState == Sonic.StateID.StateDriftDash ||
    currentState == Sonic.StateID.StateSpinBoost ||
    currentState == Sonic.StateID.StateSpinBoostCharge;

    if (Player.Input.IsPressed(Player.InputActionType.PlayerSonicboom) || Rolling)
    {
        Player.State.SetState<Sonic.StateID>(Sonic.StateID.StateSpin);
        kinematics->Velocity = vel;
    }

    if (Player.Input.IsReleased(Player.InputActionType.PlayerSonicboom))
    {
        if (Player.Input.IsDown(Player.InputActionType.PlayerBoost))
        {
            if (Memory.TryGetPointer<StatePluginBoost>(Player.State.GetStatePlugin<StatePluginBoost>(), out var out_pStatePluginBoost))
            {
                if ((out_pStatePluginBoost->Flags & StatePluginBoost.BoostFlags.IsGaugeEmpty) == 0)
                {
                    Player.State.SetState(Sonic.StateID.StateStandRoot);
                    SET_STATE_FLAG(IsBoost, true);
                }
            }
        }
        else if (Player.Status.IsGrounded())
        {
            Player.State.SetState(Sonic.StateID.StateSpringJumpHeadLand);
        }
    }
}


//===========================================================================================================
//Combat Fuctionality

Code "Disable Sonic Boom out of Combat"
//
    #lib "Globals"
    #lib "GameObject"
    #lib "Player"
//
{
    Globals.Set("Disable Sonic Boom for Regular Objects", false);

    if (Player.GetPlayerType() != Player.PlayerType.Sonic)
    {
        return;
    }

    var pGameObject = Player.Status.GetLockOnTarget();

    if (pGameObject == null)
    {
        Player.State.Discard<Sonic.StateID>(Sonic.StateID.StateSonicBoomKick);
        return;
    }
 
    // Target is an enemy if it has the GOCHealth component.
    if (GameObject.GetGOC(pGameObject, "GOCHealth") != null && !Player.Status.IsGrounded())
    {
        Player.State.Restore<Sonic.StateID>(Sonic.StateID.StateSonicBoomKick);
    }
    else
    {
        Player.State.Discard<Sonic.StateID>(Sonic.StateID.StateSonicBoomKick);
    }
}


Patch "Fix Damage from Jumping into Enemies" in "Fixes" by "Hyper" does "Fixes Sonic taking damage when jumping into enemies within a small frame window." 
//
    #include "BlackboardStatus" noemit

    #lib "HMM"
    #lib "INI"
    #lib "Player"
    #lib "BlackboardStatus"

    static bool IsConfigInitialised = false;
    static int RollDamage = 0;
    static bool IsJumpPrevious = false;
//
{
    if (!IsConfigInitialised)
    {
        var modsQuery = HMM.FindModsByName("Dynamic Roll");
        if (modsQuery.Count == 1)
        {
            string modConfigIniPath = System.IO.Path.Combine(modsQuery[0].Path, "config.ini");
            var ini = INI.Read(modConfigIniPath);

            RollDamage = INI.Parse<int>(ini["Main"]["RollDamage"], RollDamage);
        }

        IsConfigInitialised = true;
    }

    if (RollDamage == 0)
    {
        return;
    }

    Sonic.StateID NotifyJumpDamageCollision(Sonic.StateID in_stateId, Sonic.StateID[] in_stateStackTrace)
    {
        bool isJump = in_stateId == Sonic.StateID.StateJump ||
            in_stateId == Sonic.StateID.StateDoubleJump ||
            in_stateId == Sonic.StateID.StateSpinAttack ||
            in_stateId == Sonic.StateID.StateSpin ||
            in_stateId == Sonic.StateID.StateGrindDoubleJump;

        if (isJump && IS_WORLD_FLAG(IsCyberSpace))
        {
            Player.Collision.SetCollisionSphere(Player.CollisionType.Damage, 1.0f);
            Player.Collision.SetEntityCollision(false);
            IsJumpPrevious = true;
        }
        else if (IsJumpPrevious)
        {
            Player.Collision.SetCollisionSphere(Player.CollisionType.Default, 1.0f);
            Player.Collision.SetEntityCollision(true);
            IsJumpPrevious = false;
        }
        else
        {
            IsJumpPrevious = false;  
        }
    return in_stateId;  
}

    Player.State.AddStateNotifyAction<Sonic.StateID>(NotifyJumpDamageCollision);
}


Code "DriftDash do Damage" in "Gameplay/Skills"
//
    #include "BlackboardStatus" noemit

    #lib "HMM"
    #lib "INI"
    #lib "Player"

    using System.Collections.Generic;

    static bool IsConfigInitialised = false;
    static int RollDamage = 0;
    static bool _isBoostPrevious = false;

    static List<Sonic.StateID> _boostStates = new()
    {
        Sonic.StateID.StateDriftDash,
        Sonic.StateID.StateDropDash,
        Sonic.StateID.StateRecoveryJump,
        Sonic.StateID.StateSpinBoost
    };
//
{
    if (!IsConfigInitialised)
    {
        var modsQuery = HMM.FindModsByName("Dynamic Roll");
        if (modsQuery.Count == 1)
        {
            string modConfigIniPath = System.IO.Path.Combine(modsQuery[0].Path, "config.ini");
            var ini = INI.Read(modConfigIniPath);

            RollDamage = INI.Parse<int>(ini["Main"]["RollDamage"], RollDamage);
        }

        IsConfigInitialised = true;
    }

    if (RollDamage == 0)
    {
        return;
    }

    Sonic.StateID NotifyStateRunDamageCollision(Sonic.StateID in_stateId, Sonic.StateID[] in_stateStackTrace)
    {
        if (_boostStates.Contains(in_stateId))
        {
            Player.Collision.SetCollisionSphere(Player.CollisionType.Damage, 1.0f);
            Player.Collision.SetEntityCollision(false);
            _isBoostPrevious = true;
        }
        else if (_isBoostPrevious)
        {
            Player.Collision.SetCollisionSphere(Player.CollisionType.Default, 1.0f);
            Player.Collision.SetEntityCollision(true);
            _isBoostPrevious = false;
        }

        return in_stateId;
    }

    Player.State.AddStateNotifyAction<Sonic.StateID>(NotifyStateRunDamageCollision);
}


//===========================================================================================================
//Animations

Code "Unified Jump Ball Toggle" by "KE13A"
//
#include "Helpers" noemit

#lib "Memory"
#lib "Player"

static bool _isInitialised = false;
static sbyte _playerType = 0;

// runtime toggles (change these in-game)
static bool _forceSpinJump = true;     // when true -> use spinball animation for non-Tails
static bool _forceDefaultJump = false; // when true -> use vanilla jump start for all (overrides _forceSpinJump)
//
{
    // update player type pointer every frame so hook reads correct char
    _playerType = (sbyte)Player.GetPlayerType();

    if (!_isInitialised)
    {
        // get addresses of the engine functions we call
        long sigPlayAnimationEffectAddr = Memory.ReadCall
        (
            ScanSignature
            (
                "\xE8\xCC\xCC\xCC\xCC\x48\x8B\x46\x38\x48\x8B\x88\x08\x01\x00\x00\x48\x85\xC9\x74\x0C\xBA\x8E\xB4\x47\x3B\xE8\xCC\xCC\xCC\xCC\xEB\x03\x48\x8B\xC5",
                "x????xxxxxxxxxxxxxxxxxxxxxx????xxxxx"
            )
        );

        long sigSetAnimationCallerAddr = ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x41\xB0\x01\x48\x8D\x15\xCC\xCC\xCC\xCC\x48\x8B\xCE\xE8\xCC\xCC\xCC\xCC\x48\x8B\x46\x38",
            "x????xxxxxx????xxxx????xxxx"
        );

        long sigSetAnimationAddr = Memory.ReadCall(sigSetAnimationCallerAddr);

        // pin pointers so the hook can dereference them at runtime
        fixed (sbyte* p_playerType = &_playerType)
        fixed (bool* p_forceSpinJump = &_forceSpinJump)
        fixed (bool* p_forceDefaultJump = &_forceDefaultJump)
        {
            // --- Main StateJump hook (safe, follows Hyper's original pattern) ---
            WriteAsmHook
            (
                $@"
                    ; original pre-check (keeps engine conditions intact)
                    test dil, dil
                    jz   playUpdatePhase1Anim

                    ; --- when test != 0: this path usually plays JUMP_BALL + SPINJUMP ---
                    ; check if global 'force default' is set -> then play vanilla JUMP_START
                    mov  rdx, {(long)p_forceDefaultJump}
                    cmp  byte ptr [rdx], 1
                    je   useVanilla

                    ; check if global 'force spin' is set -> then play spinball (non-Tails)
                    mov  rdx, {(long)p_forceSpinJump}
                    cmp  byte ptr [rdx], 1
                    je   playJumpBall

                    ; if neither flag set: fall through to original behavior
                playUpdatePhase2Anim:
                    mov  r8b, 0xFE
                    mov  rdx, {TO_STRING_PTR("JUMP_BALL")}
                    mov  rcx, rax
                    mov  rax, {sigSetAnimationAddr}
                    call rax

                    mov  r8b, 1
                    mov  rdx, {TO_STRING_PTR("SPINJUMP")}
                    mov  rcx, rsi
                    mov  rax, {sigPlayAnimationEffectAddr}
                    call rax
                    jmp  exit

                ; if flags request spinball even when engine would've done default, use this:
                playJumpBall:
                    mov  r8b, 0xFE
                    mov  rdx, {TO_STRING_PTR("JUMP_BALL")}
                    mov  rcx, rax
                    mov  rax, {sigSetAnimationAddr}
                    call rax

                    mov  r8b, 1
                    mov  rdx, {TO_STRING_PTR("SPINJUMP")}
                    mov  rcx, rsi
                    mov  rax, {sigPlayAnimationEffectAddr}
                    call rax
                    jmp  exit

                useVanilla:
                    ; play the vanilla pre-jump animation (JUMP_START)
                    mov  r8b, 0xFE
                    mov  rdx, {TO_STRING_PTR("JUMP_START")}
                    mov  rcx, rax
                    mov  rax, {sigSetAnimationAddr}
                    call rax
                    jmp exit

                ; original label: when test == 0 (engine wants Phase1 anim)
                playUpdatePhase1Anim:
                    mov  rdx, {(long)p_playerType}
                    cmp  byte ptr [rdx], 1
                    jne  playUpdatePhase2Anim

                    mov  rdx, {(long)p_playerType}
                    cmp  byte ptr [rdx], 3
                    jne  playUpdatePhase2Anim

                    ; special-case player type == 1 (Tails) -> vanilla JUMP_START for him
                    mov  r8b, 0xFE
                    mov  rdx, {TO_STRING_PTR("JUMP_START")}
                    mov  rcx, rax
                    mov  rax, {sigSetAnimationAddr}
                    call rax
                    
                    // --- Force SPINJUMP for Amyâ€™s initial jump ---
                    mov  r8b, 0xFE
                    mov  rdx, {TO_STRING_PTR("SPINJUMP")}
                    mov  rcx, rax
                    mov  rax, {sigSetAnimationAddr}
                    call rax
                    jmp  exit
                exit:
                ",

                ScanSignature
                (
                    "\x41\xB0\xFE\x48\x8B\xC8\x40\x84\xFF\x74\x59",
                    "xxxxxxxxxxx"
                ),

                HookBehavior.Replace
            );

            // keep original caller NOP'd like Hyper did (prevents double-calls)
            WriteNop(sigSetAnimationCallerAddr, 23);

            // --- Double jump hook: still play SPINJUMP (this was stable)
            WriteAsmHook
            (
                $@"
                    mov  rdx, {TO_STRING_PTR("SPINJUMP")}
                    lea  rdx, [rdx]
                    mov  rcx, rbx
                    mov  rax, {sigPlayAnimationEffectAddr}
                    call rax
                ",

                ScanSignature
                (
                    "\x48\x8D\x15\xCC\xCC\xCC\xCC\x48\x89\xD9\xE8\xCC\xCC\xCC\xCC\x48\x8B\x43\x38",
                    "xxx????xxxx????xxxx"
                ),

                HookBehavior.Replace
            );
        }

        _isInitialised = true;
    }
}






// Code "Jump Animation Change"
// //
// 	#include "Reflection" noemit

//     #lib "Player"
// 	#lib "Reflection"
// 	#lib "SonicParameters"
// //
// {
// 	var SonicParametersInfo = Reflection.GetDataInfo<SonicParameters.Root>("player_common");
//     var previousState = Player.State.GetPreviousStateID<Sonic.StateID>();

// 	if (SonicParametersInfo.pData == null)
// 		return;

//     if (previousState == Sonic.StateID.StateDriftDash || previousState == Sonic.StateID.StateDropDash || previousState == Sonic.StateID.StateSpin)
//     {
//         RFL_SET_CONTEXTUAL_PLAYER_PARAM(SonicParametersInfo, modePackage.jump.preActionTime, 0.82f);
//     }
//     else
//     {
//         RFL_SET_CONTEXTUAL_PLAYER_PARAM(SonicParametersInfo, modePackage.jump.preActionTime, 0.18f);
//     }
// }


// // DriftDash Animation Test
// // Adjusts transition timing/animation before entering DriftDash
// Code "DriftDash Animation Test"
// //
// #include "Reflection" noemit

// #lib "Player"
// #lib "Reflection"
// #lib "SonicParameters"
// //
// {
//     var SonicParametersInfo = Reflection.GetDataInfo<SonicParameters.Root>("player_common");
//     var previousState = Player.State.GetPreviousStateID<Sonic.StateID>();    
//     var kinematics = Player.Kinematics.Get();

//     if (kinematics == null)
//         return;

//     // Only run for Sonic
//     if (Player.GetPlayerType() != Player.PlayerType.Sonic)
//         return;

//     if (SonicParametersInfo.pData == null)
//         return;

//     // Check if Sonic is in DriftDash
//     if (Player.State.GetCurrentStateID<Sonic.StateID>() == Sonic.StateID.StateDriftDash)
//     {
//         // Slow down the transition into DriftDash
// 	    RFL_SET_CONTEXTUAL_PLAYER_PARAM(SonicParametersInfo, modePackage.driftDash.preActionTime, 1.0f);
//         RFL_SET_CONTEXTUAL_PLAYER_PARAM(SonicParametersInfo, driftDash.startPreActionTime, 1.0f); // default ~0.2
//         RFL_SET_CONTEXTUAL_PLAYER_PARAM(SonicParametersInfo, driftDash.startBlendTime, 0.8f);    // lengthen the blend-in

//         // Optional: swap the pre-dash animation
//         Player.Animation.SetAnimation("SPINJUMP");
//     }
//     else
//     {
//         // Reset to defaults when not in DriftDash
//         RFL_SET_PARAM(SonicParametersInfo, driftDash.startPreActionTime, 0.2f);
//         RFL_SET_PARAM(SonicParametersInfo, driftDash.startBlendTime, 0.2f);
//     }
// }

// Code "Rolling Animation Changes"
// //
//     #include "BlackboardStatus" noemit

//     #lib "Player"
//     #lib "Time"
//     #lib "BlackboardStatus"

//     static float pressTime = 0.0f;
//     static float releaseTime = 0.0f;
// //
// {
//     var currentState = Player.State.GetCurrentStateID<Sonic.StateID>();
//     var previousState = Player.State.GetPreviousStateID<Sonic.StateID>();
  

//     if (Player.Input.IsReleased(Player.InputActionType.PlayerSonicboom) && !Player.Status.IsGrounded() /* || (currentState is Sonic.StateID.StateSpinBoostCharge or Sonic.StateID.StateJump)*/)
//     {
//         //releaseTime += Time.GetDeltaTime();
//         pressTime = 0.0f;  
//         switch (Player.GetPlayerType())
//         {
//             case Player.PlayerType.Amy:
//             {
//                 releaseTime = 0.6f;
//                 break;
//             }
//             default:
//             {
//                 releaseTime = 0.7f;
//                 break;
//             }
//         } 
//     }
//     else if (Player.Input.IsPressed(Player.InputActionType.PlayerSonicboom) && (currentState == Sonic.StateID.StateSpinBoost || currentState ==  Sonic.StateID.StateDriftDash))
//     {
//         releaseTime = 0.0f;
//         pressTime += Time.GetDeltaTime();
//     }
//     else
//     {
//         pressTime = 0.0f;
//         releaseTime = 0.0f;
//     }


//     if (pressTime > 0.0f)
//     {
//         Player.Animation.SetAnimation("JUMP_BALL");
//     }

//     // if (pressTime >= 0.2f)
//     // {
//     //     Player.Animation.SetAnimation("SPINJUMP");
//     // }

//     // if (releaseTime > 0.0f)
//     // {
//     //     switch (Player.GetPlayerType())
//     //     {
//     //         case Player.PlayerType.Amy:
//     //         {
//     //             if (releaseTime <= 0.6f)
//     //             {
//     //                 Player.Animation.SetAnimation("ATTACK_BOUNCE");
//     //             }
//     //             break;
//     //         }
//     //         default:
//     //         {
//     //             if (releaseTime <= 0.7f)
//     //             {
//     //                 Player.Animation.SetAnimation("ATTACK_BOUNCE");
//     //             }
//     //             break;
//     //         }
//     //     }
//     //     releaseTime -= Time.GetDeltaTime();    
//     // }
//     // else
//     // {
//     //     releaseTime = 0.0f;
//     // }
// }


//===========================================================================================================
//Misc. HMM Codes

Code "Always Unlocked Spin Dash" in "Cheats/Skills" by "Hyper" 
//
    #include "BlackboardStatus" noemit

    static bool _isInitialised = false;
//
{
    if (!_isInitialised)
    {
        // Unlock various components of Spin Dash.
        WriteAsmHook
        (
            $@"
                mov al, 1
                ret
            ",

            /* v1.41: 0x140AFEF70 */
            ScanSignature
            (
                "\x48\x8B\x41\x08\xF6\x40\x4C\x06",
                "xxxxxxxx"
            ),

            HookBehavior.Replace
        );

        _isInitialised = true;
    }
    
    SET_COMBAT_FLAG(IsSpinDash, true);
}


Patch "Disable Spin Charge Camera" in "Camera" by "Hyper" does 
/*
Disables the zoom camera when charging a Spin Dash.

Notes;
- It is recommended that you use this with Increased Spin Charge Rotation Speed.
*/
{
    WriteNop
    (
        /* 0x1408A67DC */
        ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x48\x8B\xCF\xBB\x24\x00\x00\x00",
            "x????xxxxxxxx"
        ),

        5
    );
}


Code "Fix Rolling in 2D" in "Fixes/Gameplay" by "Hyper" does
/*
Fixes the Drop Dash and Spin states getting stuck in 2D sections where the guide spline crosses paths with another.

Notes;
- It is highly recommended that you use this with the "Fix Drop Dash Transitions" and "Fix Spin Transitions" codes.
*/
//
    #include "Helpers" noemit

    #lib "DeltaTime"
    #lib "Globals"
    #lib "HMM"
    #lib "Memory"
    #lib "Player"
    #lib "VectorHelpers"

    #import "GOComponents"

    #load "System.Numerics.dll"

    using System.Numerics;
    
    static bool _isInitialised = false;
    static bool _isDropDashCameraDelay = true;
    static bool _isSideView = false;

    static int _sfxHandle = 0;

    static long _sigDropDashCameraDelay = 0;
    static long _sigPostureHook = 0;
    static long _sigSfxPlayer = 0;
    static long _sigSfxHandleAssignment = 0;

    static float _timeInCurrentPosition = 0.0f;
    static float _ceilingDetectionRadius = 0.01f;
    static float _ceilingDetectionTime = 0.1f;
    static float _lastYPosition = 0.0f;

    static float _airInfluenceMagnitude = 10.0f;

    static void SetDropDashCameraDelay(bool in_isEnabled)
    {
        if (_sigDropDashCameraDelay == 0)
        {
            // v1.41: 0x140956C32
            _sigDropDashCameraDelay = ScanSignature
            (
                "\x73\x2A\xF3\x0F\x10\x05\xCC\xCC\xCC\xCC\x45\x33\xC9",
                "xxxxxx????xxx"
            );

            if (_sigDropDashCameraDelay == 0)
                return;
        }
        
        if (in_isEnabled && _isDropDashCameraDelay)
        {
            WriteProtected<byte>(_sigDropDashCameraDelay, 0x73);
        }
        else
        {
            WriteProtected<byte>(_sigDropDashCameraDelay, 0xEB);
        }
    }
//
{
    Globals.Add("Fix Rolling in 2D", true);

    if (Globals.GetFlag("Fix Rolling in 2D"))
    {
        if (!_isInitialised)
        {
            _isDropDashCameraDelay = !HMM.GetCodes().Contains("Camera/Disable Drop Dash Camera Delay");

            fixed (bool* p_isSideView = &_isSideView)
            {
                // v1.41: 0x1408EA2CA
                var sigDropDashAirPosture = ScanSignature
                (
                    "\x0F\x29\xB4\x24\x80\x00\x00\x00\x48\x8D\x54\x24\x20\x0F\x10\xB7\x00\x01\x00\x00",
                    "xxxxxxxxxxxxxxxxxxxx"
                );

                // v1.41: 0x1408EA540
                var sigDropDashGroundPosture = ScanSignature
                (
                    "\x48\x8B\xC4\x48\x89\x58\x08\x48\x89\x70\x10\x48\x89\x78\x18\x55\x41\x56\x41\x57\x48\x8D\x68\xA1\x48\x81\xEC\xD0\x00\x00\x00\x4C",
                    "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
                );

                /* v1.41: 0x1408EA2B6 */
                _sigPostureHook = ScanSignature
                (
                    "\x84\xC0\x74\x10\x0F\x28\xCF",
                    "xxxxxxx"
                );

                Memory.Preserve(_sigPostureHook, 15);
                
                WriteAsmHook
                (
                    $@"
                        test   al, al
                        jnz    doGroundPosture
                        mov    rax, {sigDropDashAirPosture}
                        jmp    rax
                    doGroundPosture:
                        mov    rcx, {(long)p_isSideView}
                        cmp    byte ptr [rcx], 0
                        jnz    exit
                        movaps xmm1, xmm7
                        mov    rcx, rbx
                        mov    rax, {sigDropDashGroundPosture}
                        call   rax
                    exit:
                    ",

                    _sigPostureHook,

                    HookBehavior.Replace
                );
            }

            /* v1.41: 0x140956BC7 */
            _sigSfxPlayer = ScanSignature
            (
                "\xE8\xCC\xCC\xCC\xCC\x48\x8D\x8D\xB0\x00\x00\x00\x48\x8B\xD0\xE8\xCC\xCC\xCC\xCC\xB2\x01",
                "x????xxxxxxxxxxx????xx"
            );

            /* v1.41: 0x140956BD6 */
            _sigSfxHandleAssignment = ScanSignature
            (
                "\xE8\xCC\xCC\xCC\xCC\xB2\x01\x48\x8B\xCE\xE8\xCC\xCC\xCC\xCC\x33\xD2\x48\x8B\xCE\xE8\xCC\xCC\xCC\xCC\x48\x8B\x7E\x48",
                "x????xxxxxx????xxxxxx????xxxx"
            );

            Memory.Preserve(_sigSfxPlayer, 5);
            Memory.Preserve(_sigSfxHandleAssignment, 5);

            WriteNop(_sigSfxPlayer, 5);
            WriteNop(_sigSfxHandleAssignment, 5);

            _isInitialised = true;
        }
    }
    else
    {
        Memory.Restore(_sigPostureHook);
        Memory.Restore(_sigSfxPlayer);
        Memory.Restore(_sigSfxHandleAssignment);
        
        SetDropDashCameraDelay(true);

        _isInitialised = false;

        return;
    }

    /* Check if we're grounded as well as in side view
       to allow the drop dash to work after using ramps. */
    _isSideView = Player.Status.IsSideView() && Player.Status.IsGrounded();

    //////////////////////////////////////////////////////////////////////////////////////////////////////////
    // We have to do our own physics implementation here, since the mid-asm hook is effectively killing it. //
    //////////////////////////////////////////////////////////////////////////////////////////////////////////

    if (!Memory.TryGetPointer<GOCPlayerKinematicParams>(Player.Kinematics.Get(), out var out_pKinematics))
    {
        SetDropDashCameraDelay(true);
        return;
    }

    var state = Player.State.GetCurrentStateID<Sonic.StateID>();
    var deltaTime = DeltaTime.GetDeltaTime();
    var isGrounded = Player.Status.IsGrounded();

    if (state == Sonic.StateID.StateDropDash)
    {
        if (_sfxHandle == 0)

        if (!_isSideView)
            return;

        var worldInput = out_pKinematics->WorldInput;

        if (worldInput.Length() <= 0.0f)
            return;
        
        var forward = VectorHelpers.GetForward(out_pKinematics->Rotation);
        var dot = Vector3.Dot(forward, worldInput);

        // Decelerate if the player is holding back in the opposite direction.
        if (1.0f - (float)-Math.Min(dot, 0) < 0.15f)
            out_pKinematics->Velocity -= Vector3.Normalize(out_pKinematics->Velocity) * Player.Kinematics.GetHorizontalMagnitude() * deltaTime;
    }
    else if (state == Sonic.StateID.StateSpin)
    {
        if (isGrounded)
        {
            SetDropDashCameraDelay(false);
            Player.State.SetState<Sonic.StateID>(Sonic.StateID.StateDropDash);
            return;
        }
        
        // Ceiling detection to escape into StateFall.
        {
            if (Math.Abs(_lastYPosition - out_pKinematics->Position.Y) <= _ceilingDetectionRadius)
                _timeInCurrentPosition += deltaTime;

            if (_timeInCurrentPosition >= _ceilingDetectionTime)
            {
                // Reset Y velocity to prevent Sonic from floating in place.
                out_pKinematics->Velocity.Y = 0.0f;

                // Switch to StateFall to prevent lingering on a ceiling in StateSpin.
                Player.State.SetState<Sonic.StateID>(Sonic.StateID.StateFall);

                _timeInCurrentPosition = 0.0f;
            }
            
            _lastYPosition = out_pKinematics->Position.Y;
        }

        // Don't run code if stick is neutral.
        if (out_pKinematics->WorldInput.Length() <= 0.0f)
            return;
            
        var horzMag = Player.Kinematics.GetHorizontalMagnitude();
        var vertMag = Player.Kinematics.GetVerticalMagnitude();

        // Don't run code if we're rolling horizontally.
        if (Math.Abs(vertMag) + _airInfluenceMagnitude < Math.Abs(horzMag))
            return;

        var worldInputDirection = VectorHelpers.LookRotation(Vector3.Normalize(out_pKinematics->WorldInput));

        out_pKinematics->Rotation = Quaternion.Slerp(out_pKinematics->Rotation, worldInputDirection, 0.25f);
        out_pKinematics->Velocity += VectorHelpers.GetForward(out_pKinematics->Rotation);

        // Limit magnitude horizontally.
        if (horzMag > _airInfluenceMagnitude)
        {
            var newVelocity = out_pKinematics->Velocity * (_airInfluenceMagnitude / horzMag);

            out_pKinematics->Velocity.X = newVelocity.X;
            out_pKinematics->Velocity.Z = newVelocity.Z;
        }
    }
    else
    {
        SetDropDashCameraDelay(true);

        if (_sfxHandle != 0)
        {
            fixed (int* p_sfxHandle = &_sfxHandle)
                Player.Sound.StopSound(p_sfxHandle);

            _sfxHandle = 0;
        }
    }
}