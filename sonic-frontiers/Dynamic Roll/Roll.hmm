//===========================================================================================================
// Rolling Functionality
Code "Dynamic Roll" in "Gameplay" by "KE13A" 
//
	#include "Reflection" noemit
    #include "BlackboardStatus" noemit

    #lib "BlackboardStatus"
    #lib "Time"
    #lib "Globals"
    #lib "Memory"
    #lib "Player"

    #import "Plugins"
    #import "RollLibrary"

    #load "System.Numerics.dll"

    using System.Numerics; 

    static float springLandTimer = 0.0f;
    static bool preRoll = false;
    static float preRollTargetTime = 0.0f;
//
{
    Globals.Set("Drop Dash Over Spin Dash", false);

    var currentState = Player.State.GetCurrentStateID<Sonic.StateID>();
    var previousState = Player.State.GetPreviousStateID<Sonic.StateID>();

    var kinematics = Player.Kinematics.Get();
    float currentSpeed = Player.Kinematics.GetMagnitude();

    if (BlackboardStatus.Get() == null)
    {
        return;
    }

    // === LT pressed - State Redirects and Discards ===
    if (Player.Status.IsSideView())
    {
        Player.State.Redirect<Sonic.StateID>(Sonic.StateID.StateSpinBoost, Sonic.StateID.StateSpin);
        Player.State.Redirect<Amy.StateID>(Amy.StateID.StateSpinBoost, Amy.StateID.StateSpin);
        Player.State.Redirect<Knuckles.StateID>(Knuckles.StateID.StateSpinBoost, Knuckles.StateID.StateSpin);
        Player.State.Redirect<Tails.StateID>(Tails.StateID.StateSpinBoost, Tails.StateID.StateSpin);
    }
    else
    {
        Player.State.Redirect<Sonic.StateID>(Sonic.StateID.StateSpinBoost, Sonic.StateID.StateDriftDash);
        Player.State.Redirect<Amy.StateID>(Amy.StateID.StateSpinBoost, Amy.StateID.StateDriftDash);
        Player.State.Redirect<Knuckles.StateID>(Knuckles.StateID.StateSpinBoost, Knuckles.StateID.StateDriftDash);
        Player.State.Redirect<Tails.StateID>(Tails.StateID.StateSpinBoost, Tails.StateID.StateDriftDash);
    }

    if (RollLibrary.Rolling)
    {
        Player.State.Discard<Sonic.StateID>(Sonic.StateID.StateDropDash);
        Player.State.Discard<Amy.StateID>(Amy.StateID.StateDropDash);
        Player.State.Discard<Knuckles.StateID>(Knuckles.StateID.StateDropDash);
        Player.State.Discard<Tails.StateID>(Tails.StateID.StateDropDash);
    }
    else
    {
        Player.State.Restore<Sonic.StateID>(Sonic.StateID.StateDropDash);
        Player.State.Restore<Amy.StateID>(Amy.StateID.StateDropDash);
        Player.State.Restore<Knuckles.StateID>(Knuckles.StateID.StateDropDash);
        Player.State.Restore<Tails.StateID>(Tails.StateID.StateDropDash);           
    }

    Player.State.Discard<Sonic.StateID>(Sonic.StateID.StateSpinBoostCharge);
    Player.State.Discard<Amy.StateID>(Amy.StateID.StateSpinBoostCharge);
    Player.State.Discard<Knuckles.StateID>(Knuckles.StateID.StateSpinBoostCharge);
    Player.State.Discard<Tails.StateID>(Tails.StateID.StateSpinBoostCharge);

    // Grounded Rolling Transition
    preRollTargetTime = ((85f / currentSpeed) - 1.5f);

    if ((RollLibrary.Rolling || currentState == Sonic.StateID.StateSpinBoostCharge) && RollLibrary.rollInputDown && (RollLibrary.rollInputPressedTime < preRollTargetTime || preRollTargetTime < 0.0f))
    {
        if (previousState is Sonic.StateID.StateRun)
        {
            Player.State.SetState(Sonic.StateID.StateSpringJumpHeadLand);
            var vel = kinematics->Velocity;
            kinematics->Velocity = vel;
            preRoll = true;
        }

        if (previousState is Sonic.StateID.StateSliding)
        {
            Player.State.SetState(Sonic.StateID.StateStandRoot);
            var vel = kinematics->Velocity;
            kinematics->Velocity = vel;
            preRoll = true;
        }
    }
    else
    {
        preRoll = false;
    }

    // Airborne Roll Check
    if (!Player.Status.IsGrounded() && RollLibrary.rollInputPressed)
    {
        RollLibrary.SetAirRoll(true);
    }

    // === LT release ===
    if (RollLibrary.rollInputReleased)
    {
        if (RollLibrary.Jumped || RollLibrary.Rolling)
        {
            var vel = kinematics->Velocity;
            if (Player.Input.IsPressed(Player.InputActionType.PlayerJump))
            {
                Player.State.SetState(Sonic.StateID.StateBaseJump);
                kinematics->Velocity = vel;
            }
            else if (Player.Input.IsDown(Player.InputActionType.PlayerBoost))
            {
                if (Memory.TryGetPointer<StatePluginBoost>(Player.State.GetStatePlugin<StatePluginBoost>(), out var out_pStatePluginBoost))
                {
                    if ((out_pStatePluginBoost->Flags & StatePluginBoost.BoostFlags.IsGaugeEmpty) == 0)
                    {
                        Player.State.SetState(Sonic.StateID.StateStandRoot);
                        SET_STATE_FLAG(IsBoost, true);
                    }
                }
            }
            else if (Player.Status.IsGrounded())
            {
                Player.State.SetState(Sonic.StateID.StateSpringJumpHeadLand);
            }
        }

        RollLibrary.SetAirRoll(false);
    }


    // === Landing & Exiting checks ===
    // Re-enter DriftDash if LT is held
    if (Player.Status.IsGrounded())
    {
        if (RollLibrary.GetAirRoll() && RollLibrary.rollInputDown && currentState != Sonic.StateID.StateRecoveryJump)
        {
            var vel = kinematics->Velocity;

            if (Player.Status.IsSideView())
            {
                Player.State.SetState(Sonic.StateID.StateSpin);
                kinematics->Velocity = vel;
            }
            else
            {
                Player.State.SetState(Sonic.StateID.StateDriftDash);
            }
        }

        RollLibrary.SetAirRoll(false);
    }

    // SpringJumpHeadLand exit handling
    if (currentState == Sonic.StateID.StateSpringJumpHeadLand && !preRoll)
    {
        var vel = kinematics->Velocity;
        springLandTimer += Time.GetDeltaTime();

        if (Player.Input.IsPressed(Player.InputActionType.PlayerJump))
        {
            Player.State.SetState(Sonic.StateID.StateBaseJump);
            springLandTimer = 0.0f;
        }
        else if (Player.Input.IsPressed(Player.InputActionType.PlayerStomping) && Player.GetPlayerType() == Player.PlayerType.Sonic)
        {
            Player.State.SetState(Sonic.StateID.StateSliding);
            springLandTimer = 0.0f;
        }
        else if (Player.Input.IsPressed(Player.InputActionType.PlayerBoost))
        {
            Player.State.SetState(Sonic.StateID.StateStandRoot);
            springLandTimer = 0.0f;
        }
        else if (springLandTimer >= 0.2f)
        {
            if (Player.Status.IsGrounded())
            {
                if (RollLibrary.rollInputDown)
                {
                    if (Player.Status.IsSideView())
                    {
                        Player.State.SetState(Sonic.StateID.StateSpin);
                        kinematics->Velocity = vel;
                    }
                    else
                    {
                        Player.State.SetState(Sonic.StateID.StateDriftDash);
                    }
                }
                else if (Player.Input.IsDown(Player.InputActionType.PlayerStomping) && Player.GetPlayerType() == Player.PlayerType.Sonic)
                {
                    Player.State.SetState(Sonic.StateID.StateSliding);
                }
                else
                {
                    Player.State.SetState(Sonic.StateID.StateRun);
                }
            }
            else
            {
                Player.State.SetState(Sonic.StateID.StateFall);
                kinematics->Velocity = vel;
            }
            springLandTimer = 0.0f;
        }
        else if (kinematics != null)
        {
            float dotProduct = Vector3.Dot(Vector3.Transform(Vector3.UnitY, kinematics->Rotation), Vector3.UnitY);

            if (dotProduct < 0.01f)
            {
                Player.State.SetState<Sonic.StateID>(Sonic.StateID.StateRun);
            }
        }
    }
    else
    {
        springLandTimer = 0.0f;
    }
}


Code "Crouch with Left Trigger" in "Gameplay" by "KE13A" 
//
	#include "Reflection" noemit
    #include "BlackboardStatus" noemit

    #lib "Player"
    #lib "BlackboardStatus"
//
{
    float currentSpeed = Player.Kinematics.GetMagnitude();

    if (BlackboardStatus.Get() == null)
    {
        return;
    }

    // Crouch
    if (Player.Status.IsGrounded() && currentSpeed <= 0.0f && Player.Input.IsDown(Player.InputActionType.PlayerSonicboom) && !IS_WORLD_FLAG(IsBattle))
    {
        Player.State.Discard<Sonic.StateID>(Sonic.StateID.StateStandRoot);
        Player.State.Discard<Amy.StateID>(Amy.StateID.StateStandRoot);
        Player.State.Discard<Knuckles.StateID>(Knuckles.StateID.StateStandRoot);
        Player.State.Discard<Tails.StateID>(Tails.StateID.StateStandRoot);

        Player.State.Redirect<Sonic.StateID>(Sonic.StateID.StateSpinMove, Sonic.StateID.StateSquat);
        Player.State.Redirect<Amy.StateID>(Amy.StateID.StateSpinMove, Amy.StateID.StateSquat);
        Player.State.Redirect<Knuckles.StateID>(Knuckles.StateID.StateSpinMove, Knuckles.StateID.StateSquat);
        Player.State.Redirect<Tails.StateID>(Tails.StateID.StateSpinMove, Tails.StateID.StateSquat);
    }
    else
    {
        Player.State.Restore<Sonic.StateID>(Sonic.StateID.StateStandRoot);
        Player.State.Restore<Amy.StateID>(Amy.StateID.StateStandRoot);
        Player.State.Restore<Knuckles.StateID>(Knuckles.StateID.StateStandRoot);
        Player.State.Restore<Tails.StateID>(Tails.StateID.StateStandRoot);        
    }
}



// Code "Spin Dash Charge" by "KE13A" 
// //
// 	#include "Reflection" noemit
//     #include "BlackboardStatus" noemit

//     #lib "Player"
//     #lib "BlackboardStatus"
//     #lib "Time"

//     #load "System.Numerics.dll"

//     using System.Numerics;

//     static bool IsVelocityAdded = false;
//     static float chargeCount = 1.0f;
//     static float pressTime = 0.0f;
//     static bool SpinSFX = false;
// //
// {        
   
//     var currentState = Player.State.GetCurrentStateID<Sonic.StateID>();
//     var previousState = Player.State.GetPreviousStateID<Sonic.StateID>();

//     bool isBoomPressed = Player.Input.IsPressed(Player.InputActionType.PlayerSonicboom);
//     bool isBoomDown = Player.Input.IsDown(Player.InputActionType.PlayerSonicboom);
//     bool isBoomReleased = Player.Input.IsReleased(Player.InputActionType.PlayerSonicboom);

//     bool Rolling =
//     currentState == Sonic.StateID.StateSpin ||
//     currentState == Sonic.StateID.StateDropDash ||
//     currentState == Sonic.StateID.StateDriftDash ||
//     currentState == Sonic.StateID.StateSpinBoost;

//     float currentSpeed = Player.Kinematics.GetMagnitude();


//     if ((currentState is Sonic.StateID.StateSquat or Sonic.StateID.StateSpinMove) && Player.Input.IsPressed(Player.InputActionType.PlayerBoost))
//     {
//         Player.State.Restore<Sonic.StateID>(Sonic.StateID.StateSpinBoostCharge);
//         Player.State.Restore<Amy.StateID>(Amy.StateID.StateSpinBoostCharge);
//         Player.State.Restore<Knuckles.StateID>(Knuckles.StateID.StateSpinBoostCharge);
//         Player.State.Restore<Tails.StateID>(Tails.StateID.StateSpinBoostCharge);

//         Player.State.SetState<Sonic.StateID>(Sonic.StateID.StateSpinBoostCharge);

//     }
//     // else
//     // {
//     //     Player.State.Redirect<Sonic.StateID>(Sonic.StateID.StateSpinMove, Sonic.StateID.StateSpinBoostCharge);
//     //     Player.State.Redirect<Amy.StateID>(Amy.StateID.StateSpinMove, Amy.StateID.StateSpinBoostCharge);
//     //     Player.State.Redirect<Knuckles.StateID>(Knuckles.StateID.StateSpinMove, Knuckles.StateID.StateSpinBoostCharge);
//     //     Player.State.Redirect<Tails.StateID>(Tails.StateID.StateSpinMove, Tails.StateID.StateSpinBoostCharge);        
//     // }

//     // Player.State.Discard<Sonic.StateID>(Sonic.StateID.StateSpinBoostCharge);
//     // Player.State.Discard<Amy.StateID>(Amy.StateID.StateSpinBoostCharge);
//     // Player.State.Discard<Knuckles.StateID>(Knuckles.StateID.StateSpinBoostCharge);
//     // Player.State.Discard<Tails.StateID>(Tails.StateID.StateSpinBoostCharge);

//     // Spin Dash Charging
//     if (Player.Status.IsGrounded() && Player.Input.IsPressed(Player.InputActionType.PlayerBoost) && (currentState == Sonic.StateID.StateSpinBoostCharge) && chargeCount < 6)
//     {
//         chargeCount += 1;
//         Player.Animation.SetAnimation("JUMP_BALL"); 
//         Player.Effect.PlayAnimationEffect("SPIN_CHARGE");
//         Player.Sound.PlaySound("sn_spindash");
//         SpinSFX = true;
//     }
//     else if (currentState == Sonic.StateID.StateSpinBoostCharge && chargeCount > 1)
//     {
//         chargeCount -= 0.015f;
//     }

//     if (Player.Status.IsGrounded() && Player.Input.IsReleased(Player.InputActionType.PlayerStomping) && Rolling)
//     {
//         var kinematics = Player.Kinematics.Get();

//         if (kinematics == null)
//             return;
            
//         if (!IsVelocityAdded && !IS_WORLD_FLAG(IsCyberSpace) && !Player.Status.IsSideView())
//         {
//             kinematics->Velocity = Player.Kinematics.GetForward() * (chargeCount * 7.5f + 15.0f);

//             IsVelocityAdded = true;

//             goto Reset;
//         }

//         if (!IsVelocityAdded && IS_WORLD_FLAG(IsCyberSpace) && !Player.Status.IsSideView())
//         {
//             kinematics->Velocity = Player.Kinematics.GetForward() * (chargeCount * 7.5f + 15.0f);

//             IsVelocityAdded = true;

//             goto Reset;
//         }

// 	    if (!IsVelocityAdded && Player.Status.IsSideView())
//         {
//             kinematics->Velocity = Player.Kinematics.GetForward() * (chargeCount * 4.0f + 15.0f);

//             IsVelocityAdded = true;

//             goto Reset;
//         }
//         Reset:
//             chargeCount = 1;
//             int soundHandle = Player.Sound.PlaySound("sn_spindash");
//             Player.Sound.StopSound(&soundHandle); 
//     }
//     else
//     {
//         IsVelocityAdded = false;
//     }

//     // if (currentState != Sonic.StateID.StateSpinBoostCharge)
//     // {
//     //     chargeCount = 1;
//     // }
// }


Code "Allow Rolling During Auto Run"
//
    #include "BlackboardStatus" noemit

    #lib "Player"

    #import "Plugins"
    #import "RollLibrary"
//
{
    if (!IS_WORLD_FLAG(IsAutoRun))
    {
        return;
    }

    var kinematics = Player.Kinematics.Get();
    var vel = kinematics->Velocity;
    var currentState = Player.State.GetCurrentStateID<Sonic.StateID>();

    if (RollLibrary.rollInputPressed || RollLibrary.Rolling)
    {
        Player.State.SetState<Sonic.StateID>(Sonic.StateID.StateSpin);
        kinematics->Velocity = vel;
    }

    if (RollLibrary.rollInputReleased)
    {
        if (Player.Input.IsDown(Player.InputActionType.PlayerBoost))
        {
            if (Memory.TryGetPointer<StatePluginBoost>(Player.State.GetStatePlugin<StatePluginBoost>(), out var out_pStatePluginBoost))
            {
                if ((out_pStatePluginBoost->Flags & StatePluginBoost.BoostFlags.IsGaugeEmpty) == 0)
                {
                    Player.State.SetState(Sonic.StateID.StateStandRoot);
                    SET_STATE_FLAG(IsBoost, true);
                }
            }
        }
        else if (Player.Status.IsGrounded())
        {
            Player.State.SetState(Sonic.StateID.StateSpringJumpHeadLand);
        }
    }
}


//===========================================================================================================
//Combat Fuctionality

Code "Disable Sonic Boom out of Combat"
//
    #lib "Globals"
    #lib "GameObject"
    #lib "Player"

    static Sonic.StateID stashedState;
//
{
    Globals.Set("Disable Sonic Boom for Regular Objects", false);

    if (Player.GetPlayerType() != Player.PlayerType.Sonic)
    {
        return;
    }

    var pGameObject = Player.Status.GetLockOnTarget();

    // Target is an enemy if it has the GOCHealth component.
    if (pGameObject == null)
    {
        Player.State.Discard<Sonic.StateID>(Sonic.StateID.StateSonicBoomKick);
        return;
    }

    if (GameObject.GetGOC(pGameObject, "GOCHealth") != null && !Player.Status.IsGrounded())
    {
        Player.State.Restore<Sonic.StateID>(Sonic.StateID.StateSonicBoomKick);
    }
    else
    {
        Player.State.Discard<Sonic.StateID>(Sonic.StateID.StateSonicBoomKick);
    }
}


Patch "Fix Damage from Jumping into Enemies" in "Fixes" by "Hyper" does "Fixes Sonic taking damage when jumping into enemies within a small frame window." 
//
    #include "BlackboardStatus" noemit

    #lib "HMM"
    #lib "INI"
    #lib "Player"
    #lib "BlackboardStatus"

    static bool IsConfigInitialised = false;
    static int RollDamage = 0;
    static bool IsJumpPrevious = false;
//
{
    if (!IsConfigInitialised)
    {
        var modsQuery = HMM.FindModsByName("Dynamic Roll");
        if (modsQuery.Count == 1)
        {
            string modConfigIniPath = System.IO.Path.Combine(modsQuery[0].Path, "config.ini");
            var ini = INI.Read(modConfigIniPath);

            RollDamage = INI.Parse<int>(ini["Main"]["RollDamage"], RollDamage);
        }

        IsConfigInitialised = true;
    }

    if (RollDamage == 0)
    {
        return;
    }

    Sonic.StateID NotifyJumpDamageCollision(Sonic.StateID in_stateId, Sonic.StateID[] in_stateStackTrace)
    {
        bool isJump = in_stateId == Sonic.StateID.StateJump ||
            in_stateId == Sonic.StateID.StateDoubleJump ||
            in_stateId == Sonic.StateID.StateSpinAttack ||
            in_stateId == Sonic.StateID.StateSpin ||
            in_stateId == Sonic.StateID.StateGrindDoubleJump;

        if (isJump && IS_WORLD_FLAG(IsCyberSpace))
        {
            Player.Collision.SetCollisionSphere(Player.CollisionType.Damage, 1.0f);
            Player.Collision.SetEntityCollision(false);
            IsJumpPrevious = true;
        }
        else if (IsJumpPrevious)
        {
            Player.Collision.SetCollisionSphere(Player.CollisionType.Default, 1.0f);
            Player.Collision.SetEntityCollision(true);
            IsJumpPrevious = false;
        }
        else
        {
            IsJumpPrevious = false;  
        }
        
        return in_stateId;  
    }

    Player.State.AddStateNotifyAction<Sonic.StateID>(NotifyJumpDamageCollision);
}


Code "DriftDash do Damage" in "Gameplay/Skills"
//
    #include "BlackboardStatus" noemit

    #lib "HMM"
    #lib "INI"
    #lib "Player"

    using System.Collections.Generic;

    static bool IsConfigInitialised = false;
    static int RollDamage = 0;
    static bool _isBoostPrevious = false;

    static List<Sonic.StateID> _rollStates = new()
    {
        Sonic.StateID.StateDriftDash,
        Sonic.StateID.StateDropDash,
        Sonic.StateID.StateRecoveryJump,
        Sonic.StateID.StateSpinBoost,
        Sonic.StateID.StateSpringJumpHeadLand
    };
//
{
    if (!IsConfigInitialised)
    {
        var modsQuery = HMM.FindModsByName("Dynamic Roll");
        if (modsQuery.Count == 1)
        {
            string modConfigIniPath = System.IO.Path.Combine(modsQuery[0].Path, "config.ini");
            var ini = INI.Read(modConfigIniPath);

            RollDamage = INI.Parse<int>(ini["Main"]["RollDamage"], RollDamage);
        }

        IsConfigInitialised = true;
    }

    if (RollDamage == 0)
    {
        return;
    }

    Sonic.StateID NotifyStateRunDamageCollision(Sonic.StateID in_stateId, Sonic.StateID[] in_stateStackTrace)
    {
        if (_rollStates.Contains(in_stateId))
        {
            Player.Collision.SetCollisionSphere(Player.CollisionType.Damage, 1.0f);
            Player.Collision.SetEntityCollision(false);
            _isBoostPrevious = true;
        }
        else if (_isBoostPrevious)
        {
            Player.Collision.SetCollisionSphere(Player.CollisionType.Default, 1.0f);
            Player.Collision.SetEntityCollision(true);
            _isBoostPrevious = false;
        }

        return in_stateId;
    }

    Player.State.AddStateNotifyAction<Sonic.StateID>(NotifyStateRunDamageCollision);
}


//===========================================================================================================
//Animations

Code "Grounded Rolling Animation Changes"
//
    #include "BlackboardStatus" noemit

    #lib "Player"
    #lib "Time"
    #lib "BlackboardStatus"

    #import "RollLibrary"

    static float headLandingTime = 0.0f;
    static float unRollTargetTime = 0.04f; //0.065f

    static bool airFlipLand = false;
    static float airFlipLandTimer = 0.15f;
    static float airFlipLandTime = 0.0f;
//
{
    var currentState = Player.State.GetCurrentStateID<Sonic.StateID>();
    var previousState = Player.State.GetPreviousStateID<Sonic.StateID>();

    if (Player.Status.IsGrounded() && RollLibrary.Jumped)
    {
        if (RollLibrary.Rolling)
        {
            Player.Effect.PlayAnimationEffect("SPINJUMP");
        }
        else
        {
            Player.Effect.StopAnimationEffects();
        }

        if (RollLibrary.GetAirFlip())
        {
            airFlipLand = true;
            airFlipLandTime = airFlipLandTimer;
            RollLibrary.SetAirFlip(false);
        }
    }

    Console.WriteLine($"Air Flip Landing Time: {airFlipLandTime}");

    // Air Flip Landing Animation
    if (airFlipLand && currentState is Sonic.StateID.StateRun)
    {
        if (airFlipLandTime > 0.0f)
        {
            airFlipLandTime -= Time.GetDeltaTime() * RollLibrary.timeScale;
            Player.Animation.SetAnimation("JUMP_BALL");
            //Player.Effect.PlayAnimationEffect("SPINJUMP");
            //Player.Animation.SetAnimation("SPRINGJUMP_E");
        }
        else
        {
            airFlipLandTime = 0.0f
            Player.State.SetState(Sonic.StateID.StateStandRoot);      
            Player.State.SetState(Sonic.StateID.StateRun);  
            airFlipLand = false;    
        }
    }
    else
    {
        airFlipLandTime = 0.0f
    }

    //Roll Transition Animations
    if (currentState == Sonic.StateID.StateSpringJumpHeadLand)
    {
        headLandingTime += Time.GetDeltaTime() * RollLibrary.timeScale;

        // PreRoll Animation
        if (RollLibrary.rollInputDown)
        {
            Player.Animation.SetAnimation("JUMP_BALL");
        }

        // Roll Exit Animation   
        if (!RollLibrary.rollInputReleased && RollLibrary.Rolled)
        {
            if (headLandingTime > 0.0f && headLandingTime < unRollTargetTime)
            {
                Player.Effect.PlayAnimationEffect("SPINJUMP");
            }
            else if (headLandingTime >= unRollTargetTime)
            {
                Player.Effect.StopAnimationEffects();
            }
        }
    }
    else
    {
        headLandingTime = 0.0f;     
    }
}


Code "Aerial Rolling Animation Changes"
//
    #lib "Player"

    #import "RollLibrary"

    static float preRollTargetTime = 0.125f; //0.2f
    static float releaseTimer = 0.085f; //0.225f
    static float releaseTime = 0.0f;
    static bool airRolled = false;
    static string fallAnimation = "";    
//
{
    var currentState = Player.State.GetCurrentStateID<Sonic.StateID>();
    var previousState = Player.State.GetPreviousStateID<Sonic.StateID>();

    bool currentFriendsAerialState =
    Player.State.GetCurrentStateID<Amy.StateID>() == Amy.StateID.StateHighJump ||
    Player.State.GetCurrentStateID<Amy.StateID>() == Amy.StateID.StatePropellerJump ||
    Player.State.GetCurrentStateID<Amy.StateID>() == Amy.StateID.StatePropellerHover ||
    Player.State.GetCurrentStateID<Knuckles.StateID>() == Knuckles.StateID.StateGliding ||
    Player.State.GetCurrentStateID<Tails.StateID>() == Tails.StateID.StateTailsFly;

    bool previousFriendAerialStates =
    Player.State.GetPreviousStateID<Amy.StateID>() == Amy.StateID.StateHighJump ||
    Player.State.GetPreviousStateID<Amy.StateID>() == Amy.StateID.StatePropellerJump ||
    Player.State.GetPreviousStateID<Amy.StateID>() == Amy.StateID.StatePropellerHover ||
    Player.State.GetPreviousStateID<Knuckles.StateID>() == Knuckles.StateID.StateGliding ||
    Player.State.GetPreviousStateID<Tails.StateID>() == Tails.StateID.StateTailsFly;

    bool boomKickOutOfCombat =
    currentState == Sonic.StateID.StateSonicBoomKick &&
    Player.Status.GetLockOnTarget() == null;

    float currentSpeed = Player.Kinematics.GetMagnitude();

    // Console.WriteLine($"Air Roll: {RollLibrary.GetAirRoll()}");
    // Console.WriteLine($"Air Flip: {RollLibrary.GetAirFlip()}");

    if (boomKickOutOfCombat)
    {
        Player.State.Redirect<Sonic.StateID>(Sonic.StateID.StateSonicBoomKick, Sonic.StateID.StateSpinBoostCharge);
        
        if (currentState == Sonic.StateID.StateSonicBoomKick)
        {
            Player.State.SetState(Sonic.StateID.StateSpinBoostCharge);       
        }
    }
    else
    {
        Player.State.Redirect<Sonic.StateID>(Sonic.StateID.StateSonicBoomKick, Sonic.StateID.StateSonicBoomKick);
    }

    if (Player.Status.IsGrounded())
    {
        releaseTime = 0.0f;
        return;
    }

    if (!RollLibrary.Jumping)
    {
        if (RollLibrary.GetAirRoll() && currentFriendsAerialState)
        {
            Player.Effect.StopAnimationEffects();
        }

        RollLibrary.SetAirFlip(false);
        releaseTime = 0.0f;
        return;
    }    

    void StartFlip()
    {
        if (!RollLibrary.GetAirFlip())
        {
            fallAnimation = (currentSpeed >= 30.0f) ? "BUMP_JUMP_START_LOOP" : "FALL";
            releaseTime = releaseTimer;
            airRolled = false;
            RollLibrary.SetAirFlip(true);
        }
    }

    if (RollLibrary.GetAirRoll())
    {
        airRolled = true;
    }

    if (currentState == Sonic.StateID.StateDoubleJump)
    {
        RollLibrary.SetAirFlip(false);
    }

    if (RollLibrary.rollInputPressed)
    {
        releaseTime = 0.0f;
    }

    if (RollLibrary.rollInputDown)
    {
        if ((currentState is Sonic.StateID.StateJump or Sonic.StateID.StateFall) && previousFriendAerialStates)
        {
            RollLibrary.rollInputPressedTime = 1.0f;
        }

        if ((currentState is Sonic.StateID.StateJump or Sonic.StateID.StateFall) && (RollLibrary.Rolled))
        {
            RollLibrary.rollInputPressedTime = 1.0f;
        }        
    }

    if (RollLibrary.rollInputReleased)
    {
        if (airRolled)
        {
            StartFlip();
        }
    }

    // Air Roll Animation Sequence
    if (RollLibrary.GetAirRoll())
    {
        RollLibrary.SetAirFlip(false);

        if (RollLibrary.rollInputPressedTime > 0.0f && RollLibrary.rollInputPressedTime < preRollTargetTime)
        {
            Player.Effect.StopAnimationEffects();
            Player.Animation.SetAnimation("JUMP_BALL");       
        }
        else if (RollLibrary.rollInputPressedTime >= preRollTargetTime)
        {
            Player.Effect.PlayAnimationEffect("SPINJUMP");
        }
    }

    // Air Flip Animation Sequence
    if (!RollLibrary.GetAirRoll() && RollLibrary.GetAirFlip())
    {
        Player.Effect.StopAnimationEffects();

        if(releaseTime > 0.0f)
        {
            releaseTime -= Time.GetDeltaTime() * RollLibrary.timeScale;
            Player.Animation.SetAnimation("JUMP_BALL");
        }
        else
        {
            releaseTime = 0.0f;
            //Player.Animation.SetAnimation(fallAnimation);
            Player.Animation.SetAnimation("FALL");

        }
    }
}


//===========================================================================================================
//Misc. HMM Codes

Code "Always Unlocked Spin Dash" in "Cheats/Skills" by "Hyper" 
//
    #include "BlackboardStatus" noemit

    static bool _isInitialised = false;
//
{
    if (!_isInitialised)
    {
        // Unlock various components of Spin Dash.
        WriteAsmHook
        (
            $@"
                mov al, 1
                ret
            ",

            /* v1.41: 0x140AFEF70 */
            ScanSignature
            (
                "\x48\x8B\x41\x08\xF6\x40\x4C\x06",
                "xxxxxxxx"
            ),

            HookBehavior.Replace
        );

        _isInitialised = true;
    }
    
    SET_COMBAT_FLAG(IsSpinDash, true);
}


Patch "Disable Spin Charge Camera" in "Camera" by "Hyper" does 
/*
Disables the zoom camera when charging a Spin Dash.

Notes;
- It is recommended that you use this with Increased Spin Charge Rotation Speed.
*/
{
    WriteNop
    (
        /* 0x1408A67DC */
        ScanSignature
        (
            "\xE8\xCC\xCC\xCC\xCC\x48\x8B\xCF\xBB\x24\x00\x00\x00",
            "x????xxxxxxxx"
        ),

        5
    );
}


Code "Fix Rolling in 2D" in "Fixes/Gameplay" by "Hyper" does
/*
Fixes the Drop Dash and Spin states getting stuck in 2D sections where the guide spline crosses paths with another.

Notes;
- It is highly recommended that you use this with the "Fix Drop Dash Transitions" and "Fix Spin Transitions" codes.
*/
//
    #include "Helpers" noemit

    #lib "DeltaTime"
    #lib "Globals"
    #lib "HMM"
    #lib "Memory"
    #lib "Player"
    #lib "VectorHelpers"

    #import "GOComponents"

    #load "System.Numerics.dll"

    using System.Numerics;
    
    static bool _isInitialised = false;
    static bool _isDropDashCameraDelay = true;
    static bool _isSideView = false;

    static int _sfxHandle = 0;

    static long _sigDropDashCameraDelay = 0;
    static long _sigPostureHook = 0;
    static long _sigSfxPlayer = 0;
    static long _sigSfxHandleAssignment = 0;

    static float _timeInCurrentPosition = 0.0f;
    static float _ceilingDetectionRadius = 0.01f;
    static float _ceilingDetectionTime = 0.1f;
    static float _lastYPosition = 0.0f;

    static float _airInfluenceMagnitude = 10.0f;

    static void SetDropDashCameraDelay(bool in_isEnabled)
    {
        if (_sigDropDashCameraDelay == 0)
        {
            // v1.41: 0x140956C32
            _sigDropDashCameraDelay = ScanSignature
            (
                "\x73\x2A\xF3\x0F\x10\x05\xCC\xCC\xCC\xCC\x45\x33\xC9",
                "xxxxxx????xxx"
            );

            if (_sigDropDashCameraDelay == 0)
                return;
        }
        
        if (in_isEnabled && _isDropDashCameraDelay)
        {
            WriteProtected<byte>(_sigDropDashCameraDelay, 0x73);
        }
        else
        {
            WriteProtected<byte>(_sigDropDashCameraDelay, 0xEB);
        }
    }
//
{
    Globals.Add("Fix Rolling in 2D", true);

    if (Globals.GetFlag("Fix Rolling in 2D"))
    {
        if (!_isInitialised)
        {
            _isDropDashCameraDelay = !HMM.GetCodes().Contains("Camera/Disable Drop Dash Camera Delay");

            fixed (bool* p_isSideView = &_isSideView)
            {
                // v1.41: 0x1408EA2CA
                var sigDropDashAirPosture = ScanSignature
                (
                    "\x0F\x29\xB4\x24\x80\x00\x00\x00\x48\x8D\x54\x24\x20\x0F\x10\xB7\x00\x01\x00\x00",
                    "xxxxxxxxxxxxxxxxxxxx"
                );

                // v1.41: 0x1408EA540
                var sigDropDashGroundPosture = ScanSignature
                (
                    "\x48\x8B\xC4\x48\x89\x58\x08\x48\x89\x70\x10\x48\x89\x78\x18\x55\x41\x56\x41\x57\x48\x8D\x68\xA1\x48\x81\xEC\xD0\x00\x00\x00\x4C",
                    "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
                );

                /* v1.41: 0x1408EA2B6 */
                _sigPostureHook = ScanSignature
                (
                    "\x84\xC0\x74\x10\x0F\x28\xCF",
                    "xxxxxxx"
                );

                Memory.Preserve(_sigPostureHook, 15);
                
                WriteAsmHook
                (
                    $@"
                        test   al, al
                        jnz    doGroundPosture
                        mov    rax, {sigDropDashAirPosture}
                        jmp    rax
                    doGroundPosture:
                        mov    rcx, {(long)p_isSideView}
                        cmp    byte ptr [rcx], 0
                        jnz    exit
                        movaps xmm1, xmm7
                        mov    rcx, rbx
                        mov    rax, {sigDropDashGroundPosture}
                        call   rax
                    exit:
                    ",

                    _sigPostureHook,

                    HookBehavior.Replace
                );
            }

            /* v1.41: 0x140956BC7 */
            _sigSfxPlayer = ScanSignature
            (
                "\xE8\xCC\xCC\xCC\xCC\x48\x8D\x8D\xB0\x00\x00\x00\x48\x8B\xD0\xE8\xCC\xCC\xCC\xCC\xB2\x01",
                "x????xxxxxxxxxxx????xx"
            );

            /* v1.41: 0x140956BD6 */
            _sigSfxHandleAssignment = ScanSignature
            (
                "\xE8\xCC\xCC\xCC\xCC\xB2\x01\x48\x8B\xCE\xE8\xCC\xCC\xCC\xCC\x33\xD2\x48\x8B\xCE\xE8\xCC\xCC\xCC\xCC\x48\x8B\x7E\x48",
                "x????xxxxxx????xxxxxx????xxxx"
            );

            Memory.Preserve(_sigSfxPlayer, 5);
            Memory.Preserve(_sigSfxHandleAssignment, 5);

            WriteNop(_sigSfxPlayer, 5);
            WriteNop(_sigSfxHandleAssignment, 5);

            _isInitialised = true;
        }
    }
    else
    {
        Memory.Restore(_sigPostureHook);
        Memory.Restore(_sigSfxPlayer);
        Memory.Restore(_sigSfxHandleAssignment);
        
        SetDropDashCameraDelay(true);

        _isInitialised = false;

        return;
    }

    /* Check if we're grounded as well as in side view
       to allow the drop dash to work after using ramps. */
    _isSideView = Player.Status.IsSideView() && Player.Status.IsGrounded();

    //////////////////////////////////////////////////////////////////////////////////////////////////////////
    // We have to do our own physics implementation here, since the mid-asm hook is effectively killing it. //
    //////////////////////////////////////////////////////////////////////////////////////////////////////////

    if (!Memory.TryGetPointer<GOCPlayerKinematicParams>(Player.Kinematics.Get(), out var out_pKinematics))
    {
        SetDropDashCameraDelay(true);
        return;
    }

    var state = Player.State.GetCurrentStateID<Sonic.StateID>();
    var deltaTime = DeltaTime.GetDeltaTime();
    var isGrounded = Player.Status.IsGrounded();

    if (state == Sonic.StateID.StateDropDash)
    {
        if (_sfxHandle == 0)

        if (!_isSideView)
            return;

        var worldInput = out_pKinematics->WorldInput;

        if (worldInput.Length() <= 0.0f)
            return;
        
        var forward = VectorHelpers.GetForward(out_pKinematics->Rotation);
        var dot = Vector3.Dot(forward, worldInput);

        // Decelerate if the player is holding back in the opposite direction.
        if (1.0f - (float)-Math.Min(dot, 0) < 0.15f)
            out_pKinematics->Velocity -= Vector3.Normalize(out_pKinematics->Velocity) * Player.Kinematics.GetHorizontalMagnitude() * deltaTime;
    }
    else if (state == Sonic.StateID.StateSpin)
    {
        if (isGrounded)
        {
            SetDropDashCameraDelay(false);
            Player.State.SetState<Sonic.StateID>(Sonic.StateID.StateDropDash);
            return;
        }
        
        // Ceiling detection to escape into StateFall.
        {
            if (Math.Abs(_lastYPosition - out_pKinematics->Position.Y) <= _ceilingDetectionRadius)
                _timeInCurrentPosition += deltaTime;

            if (_timeInCurrentPosition >= _ceilingDetectionTime)
            {
                // Reset Y velocity to prevent Sonic from floating in place.
                out_pKinematics->Velocity.Y = 0.0f;

                // Switch to StateFall to prevent lingering on a ceiling in StateSpin.
                Player.State.SetState<Sonic.StateID>(Sonic.StateID.StateFall);

                _timeInCurrentPosition = 0.0f;
            }
            
            _lastYPosition = out_pKinematics->Position.Y;
        }

        // Don't run code if stick is neutral.
        if (out_pKinematics->WorldInput.Length() <= 0.0f)
            return;
            
        var horzMag = Player.Kinematics.GetHorizontalMagnitude();
        var vertMag = Player.Kinematics.GetVerticalMagnitude();

        // Don't run code if we're rolling horizontally.
        if (Math.Abs(vertMag) + _airInfluenceMagnitude < Math.Abs(horzMag))
            return;

        var worldInputDirection = VectorHelpers.LookRotation(Vector3.Normalize(out_pKinematics->WorldInput));

        out_pKinematics->Rotation = Quaternion.Slerp(out_pKinematics->Rotation, worldInputDirection, 0.25f);
        out_pKinematics->Velocity += VectorHelpers.GetForward(out_pKinematics->Rotation);

        // Limit magnitude horizontally.
        if (horzMag > _airInfluenceMagnitude)
        {
            var newVelocity = out_pKinematics->Velocity * (_airInfluenceMagnitude / horzMag);

            out_pKinematics->Velocity.X = newVelocity.X;
            out_pKinematics->Velocity.Z = newVelocity.Z;
        }
    }
    else
    {
        SetDropDashCameraDelay(true);

        if (_sfxHandle != 0)
        {
            fixed (int* p_sfxHandle = &_sfxHandle)
                Player.Sound.StopSound(p_sfxHandle);

            _sfxHandle = 0;
        }
    }
}